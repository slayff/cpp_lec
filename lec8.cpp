//Сегодня кода не будет (ну почти)
//
//Раньше строки реализовывались через идиому Copy on Write:
//Строчка копировалась, при попытке ее изменения.
string s1;
string s2 = s1;
cout << s2[0]; // Здесь строчка не скопировалась
s2[0] = 'A'; // А вот здесь скопировалась.

// Но от этой идеологии отказались по некоторым причинам.
// Теперь используют принцип Short String Optimization
// Когда строчка довольно короткая (например, длины <=15),
// то она хранится на стеке.
// Это может быть организовано, через union:
union U {
    char s[16];
    struct Base {
        char * data;
        size_t sz;
    }
};
// Union позволяет в run-time по разному использовать одну и ту же область памяти.
// В данном примере - либо как char, либо как struct

// ========================================
// Последняя тема в этом курсе - сборка программ, единицы трансляции.
// ========================================
// # - директива препроцессора. Тот код файл, что внутри <> просто вставляется в вашу программу.
// В общем, тут было много слов, но суть такая, что лучше отделять детали реализации от
// публичного интерфейса.
// Публичный интерфейс объявляется в файле-хедере - lib.h
// Реализация объявляется в lib.cpp, в которой первая строчка:
#include "lib.h"
// Тогда в main.cpp мы подключим только хедер.
// При изменении внутренней реализации нужно будет перекомпилировать только lib.cpp, а main.cpp
// пересобрать. В то же время при изменении кода в main.cpp не нужно будет перекомпилировать lib.cpp
// lib.cpp <-----> lib.h <-----> main.cpp
// Внутри одной единицы трансляции может быть сколько угодно деклараций одного и того же,
// но только одно определение.
//
// Чтобы не произошло такого, что в одной единице трансляции мы определим один и тот же код много
// раз, нужно прописать:
#pragma once
// (То есть, если вдруг есть lib2.h в котором подключенен #include <lib.h> и в main.cpp 
// мы подключаем и lib.h и lib2.h)
//
// Inline функции:
inline foo(int x) {}
// Вставляет код функции в программу "как есть" или говорит компановщику, что не нужно
// проверять правило одного определения:
// В пределах одной единицы трансляции должно быть не более одного определения сущности.
// Исключения - шаблонные функции, inline функции.
